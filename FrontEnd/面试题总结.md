# Vue2双向数据绑定原理
首先通过Object.defineProperty()对数据进行劫持监听，然后在模板解析的时候生成一系列订阅者，这些订阅者就负责管理数据的更新，然后把这些订阅者都添加到一个统一管理的方法去，这样当监听到数据发生变化时，会调用统一管理方法的通知方法，然后这个方法会通知所有的订阅者进行更新，这就是双向绑定的原理，其中发布者指绑定的数据（set），订阅者是指管理数据更新的对象（模板解析时添创建订阅者，然后通过触发get方法把订阅者添加到统一管理方法中）

# 简述vue生命周期
befroreCreate 组件实例创建之初  
created 组件实例完全创建  
beforeMount 组件实例挂载之前  
mounted 组件挂载到实例上去之后  
beforeUpdate 组件数据发生变化，视图更新之前  
updated 视图更新后  
beforeDestory(beforeUnmount) 组件实例销毁前  
destoryed(unmounted) 组件实例销毁后  
进入组件默认执行：befroreCreate->create->beforeMounted->mounted

# 父组件子组件的生命周期执行顺序
父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted  
即先把父组件数据准备后以便于传入子组件再执行子组件所有渲染，最后父组件再渲染出来

# 发送请求是放在created还是mounted
具体看项目实际需求，如果有引用子组件，并且子组件展示数据比父组件的优先级高，则父组件的请求放在mounted，子组件则无所谓，除非它又符合上述情况

# 为何不放在beforeCreate
因为beforeCreate无法调用methods，假如请求封装成了一个methods则无法正常调用

# beforeCreate和created区别
1、beforeCreate没有$data  
2、created可以调用methods

# created如何获取dom
1、异步操作方法，如setTimeout,promise等  
2、this.$nextTick(()=>{})

# keep-alive会执行的生命周期
activated（第一次进入在mounted后执行，第二次后进入该组件只会执行它）  
deactiveted

# computed与watch的区别
1、computed支持缓存  
2、watch支持异步操作

# watch的3个属性
deep  
immediate  
handler

# vuex五大核心
1.state 全局共享属性  
2.getters 类似于组件的computed，可针对于state进行二次操作  
3.mutations 存放同步方法  
4.actions 存放异步方法，并且是来提交mutations  
5.module 

# vuex的工作流程
state(负责状态管理，类似于vue中的data，用于初始化数据)  
mutation(专用于修改state中的数据，通过commit触发)  
action(可以处理异步，通过dispatch触发，不能直接修改state，首先在组件中通过dispatch触发action，然后在action函数内部commit触发mutation，通过mutation修改state状态值)  
getter(Vuex中的计算属性，相当于vue中的computed,依赖于state状态值，状态值一旦改变，getter会重新计算，也就是说，当一个数据依赖于另一个数据发生变化时，就要使用getter)  
module(模块化管理)

# vuex的语法糖
1、mapState  
2、mapMutations  
3、mapActions  
4、mapGetters  
注意：mapState和mapGetter的使用只能在computed计算属性中，mapMutations和mapActions使用的时候只能在methods中调用否则报错

# Vuex持久化存储
vuex本身不是持久化存储，刷新页面会重置，如果要实现需以下两种方法  
1、手动处理存localStorage  
2、使用第三方库

# vue-router原理
通过hash与History interface两种方式实现前端路由，更新视图但不重新请求页面  
1、hash，由于改变url的hash部分不会导致页面刷新，所以可以修改url的hash，然后通过`hashchange`方法监听hash的变化从而实现页面跳转(渲染)，兼容性好，但不够美观，因为url地址带有#  
2、history模式，通过`pushState`和`replaceState`修改url，然后通过`popstate`监听url变化实现跳转渲染
区别：  
1、url表示不一样
2、兼容性不一样
3、url上需要传值的方式不一样
4、刷新的时候表现不一样

# 导航守卫
1、全局：beforeEach(进入页面校验登录),afterEach  
2、路由独享守卫:beforeEnter  
3、组件内守卫:beforeRouteEnter,beforeRouteUpdate,beforeRouteLeave

# 移动端1px问题(https://juejin.cn/post/6959736170158751780)
出现原因：CSS 中的 1px 并不能和移动设备上的 1px 划等号，与设备的像素比有关，即`window.devicePixelRatio = 设备的物理像素 / CSS像素`，假如像素比是2，则1px实际会用2像素点来渲染  
1、图片代替  
2、background渐变
```
background-position: left top;
background-image: -webkit-gradient(linear,left bottom,left top,color-stop(0.5,transparent),color-stop(0.5,#e0e0e0),to(#e0e0e0));
```
3、伪元素先放大后缩小
```
.hairline{
  position: relative;
  &::after{
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    height: 1px;
    width: 100%;
    transform: scaleY(0.5);
    transform-origin: 0 0;
    background-color: #EDEDED;
  }
}
```
4、设置viewport解决问题  
利用viewport+rem+js 实现的，边框1px直接写上自动转换。即根据设备的devicePixelRatio设置不一样的viewport

# 移动端实现0.5px的细线
1、viewport：<meta name="viewport" content="width=device-width,initial-scale=0.5, minimum-scale=0.5, maximum-scale=0.5"/>
2、伪元素缩放：transform: scale(0.5);

# v-if和v-show的区别
v-if如果不符合条件时，直接就不渲染该元素，也就是页面上实际上没有该元素，适用于切换频率较低的场景，v-show如果不符合条件时，只是会把该元素加上样式display:none进行隐藏，实际上元素是存在的，适用于切换频率较高的场景

# v-if和v-show的优先级
v-if 的优先级更高

# vue3和vue2的区别(https://segmentfault.com/a/1190000042570487)
1、双向数据绑定原理不同
```
Vue2:Object.definePropety()  
Vue3:new Proxy()  
```
2、生命周期钩子函数不同  
3、vue3支持多根节点  
4、支持的API类型不同（Vue2只支持选项式api，Vue3支持组合式api而且兼容选项式api）  
5、Vue3增加了事件缓存  
6、虚拟DOM上增加 patchFlag 字段，帮助 diff 时区分静态节点，以及不同类型的动态节点。一定程度地减少节点本身及其属性的比对  
7、组件间的传值方式不一样  
8、TypeScript支持  
9、v-if和v-for优先级不同了
```
Vue2:for>if
Vue3:if>for
```
# 什么是组合式 API
组合式 API (Composition API) 是一系列 API 的集合，使我们可以使用函数而不是声明选项的方式书写 Vue 组件

# setup()和<script setup>
1、setup() 钩子是在组件中使用组合式 API 的入口  
2、<script setup> 是在单文件组件 (SFC) 中使用组合式 API 的编译时语法糖

# vue组件通信方式(https://juejin.cn/post/6844903887162310669)
1、父子组件通信: props; $parent / $children; provide / inject ; ref ;  $attrs / $listeners  
2、兄弟组件通信: eventBus ; 	vuex  
3、跨级通信:  eventBus；Vuex；provide / inject 、$attrs / $listeners

# 浏览器从输入网址到页面展示的过程
1、URL 输入  
2、DNS 解析  
3、建立 TCP 连接  
4、发送 HTTP / HTTPS 请求（建立 TLS 连接）  
5、服务器响应请求  
6、浏览器解析渲染页面  
7、HTTP 请求结束，断开 TCP 连接


# 获取对象所有属性
1、Object.keys()  
2、forin遍历

# 遍历数组的方式
1、for  
2、map  
3、filter

# 原型和原型链
1、原型  
函数都有`prototype`属性，这个就是原型，因为它的值是个对象，所以也可以称为原型对象，作用如下：
```
(1)可以放一些属性和方法
(2)可以继承
```
2、原型链  
每个对象都有`__proto__`属性，指向它的构造函数的原型对象(例如const a= new Array()，那么a._proto_指向Array.prototype),然后指向的这个原型对象也是对象，所以它也有`__proto__`属性，也指向它的构造函数的原型对象，这样一层一层往上，最终到null为止，这种链式结构就叫原型链

# 继承
好处：继承可以使得子类具有父类别的各种属性和方法，而不需要再次编写相同的代码  
1、原型链继承  
```
function Parent() {
    this.name = 'parent1';
    this.play = [1, 2, 3]
}
function Child() {
    this.type = 'child2';
}
Child1.prototype = new Parent();
console.log(new Child())
缺点：父类的引用属性会被共享，即有多个对象时，修改其中一个会影响其他对象，如：
var s1 = new Child();
var s2 = new Child();
s1.play.push(4);
console.log(s1.play, s2.play); // [1,2,3,4]
```
2、构造函数继承（借助call）  
```
function Parent(){
    this.name = 'parent1';
}
Parent.prototype.getName = function () {
    return this.name;
}
function Child(){
    Parent1.call(this);
    this.type = 'child'
}
let child = new Child();
console.log(child);  // 没问题
console.log(child.getName());  // 会报错
可以看到，父类原型对象中一旦存在父类之前自己定义的方法，那么子类将无法继承这些方法
相比第一种原型链继承方式，父类的引用属性不会被共享，优化了第一种继承方式的弊端，但是只能继承父类的实例属性和方法，不能继承原型属性或者方法
```
3、组合继承（原型链+构造函数）  
```
function Parent3 () {
    this.name = 'parent3';
    this.play = [1, 2, 3];
}
Parent3.prototype.getName = function () {
    return this.name;
}
function Child3() {
    // 第二次调用 Parent3()
    Parent3.call(this);
    this.type = 'child3';
}
// 第一次调用 Parent3()
Child3.prototype = new Parent3();
// 手动挂上构造器，指向自己的构造函数
Child3.prototype.constructor = Child3;
var s3 = new Child3();
var s4 = new Child3();
s3.play.push(4);
console.log(s3.play, s4.play);  // 不互相影响
console.log(s3.getName()); // 正常输出'parent3'
console.log(s4.getName()); // 正常输出'parent3'
这种方式看起来就没什么问题，方式一和方式二的问题都解决了，但是从上面代码我们也可以看到 Parent3 执行了两次，造成了多构造一次的性能开销
```
4、原型式继承(Object.create)  
```
let parent4 = {
    name: "parent4",
    friends: ["p1", "p2", "p3"],
    getName: function() {
      return this.name;
    }
  };

  let person4 = Object.create(parent4);
  person4.name = "tom";
  person4.friends.push("jerry");

  let person5 = Object.create(parent4);
  person5.friends.push("lucy");

  console.log(person4.name); // tom
  console.log(person4.name === person4.getName()); // true
  console.log(person5.name); // parent4
  console.log(person4.friends); // ["p1", "p2", "p3","jerry","lucy"]
  console.log(person5.friends); // ["p1", "p2", "p3","jerry","lucy"]
这种继承方式的缺点也很明显，因为Object.create 方法实现的是浅拷贝，多个实例的引用类型属性指向相同的内存，存在篡改的可能
```
5、寄生式继承  
```
let parent5 = {
    name: "parent5",
    friends: ["p1", "p2", "p3"],
    getName: function() {
        return this.name;
    }
};

function clone(original) {
    let clone = Object.create(original);
    clone.getFriends = function() {
        return this.friends;
    };
    return clone;
}

let person5 = clone(parent5);

console.log(person5.getName()); // parent5
console.log(person5.getFriends()); // ["p1", "p2", "p3"]
其优缺点也很明显，跟上面讲的原型式继承一样
```
6、寄生组合式继承
```
function clone (parent, child) {
    // 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程
    child.prototype = Object.create(parent.prototype);
    child.prototype.constructor = child;
}

function Parent6() {
    this.name = 'parent6';
    this.play = [1, 2, 3];
}
Parent6.prototype.getName = function () {
    return this.name;
}
function Child6() {
    Parent6.call(this);
    this.friends = 'child5';
}

clone(Parent6, Child6);

Child6.prototype.getFriends = function () {
    return this.friends;
}

let person6 = new Child6(); 
console.log(person6); //{friends:"child5",name:"child5",play:[1,2,3],__proto__:Parent6}
console.log(person6.getName()); // parent6
console.log(person6.getFriends()); // child5
```

# 防抖和节流
1、防抖  
在一定时间内只执行最后一次，每次触发事件都从头开始计时(搜索请求)
```
let timer = null
function fn(){

if(timer){
  clearTimeout(timer)
}
timer = setTimerout(()=>{})
}
```
2、节流  
在设定时间内只触发一次，在定时器没执行完之前都不触发事件(scroll,click事件等)
```
let timer = null
function fn(){

if(timer){
  return
}
timer = setTimerout(()=>{
  timer=null
})
}
```

# BFC是什么
官方：BFC即块级格式化上下文，具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。  
个人理解：是页面元素的一种特性，具有这种特性的元素可以看作是一个独立的容器，它内部的布局不会影响到外面的元素  
触发方式：  
1、body根元素  
2、float 除 none 以外的值  
3、position (absolute、fixed)  
4、display 为 inline-block、table-cells、flex  
5、overflow 除了 visible 以外的值 (hidden、auto、scroll)

# 外边距重叠是什么？
外边距重叠是指两个或多个盒子(可能相邻也可能嵌套)的相邻边界(其间没有任何非空内容、补白、边框)重合在一起而形成一个单一边界  
解决办法：  
1、overflow  
2、float  
3、postion  
4、display:inline-block

# 闭包是什么，作用
闭包是指有权访问另一个函数作用域中的变量的函数，简单来讲就是函数嵌套函数，嵌套函数使用到它上一级的变量，这种组合就叫闭包    
牛客：闭包是指有权访问另一个函数作用域中变量的函数，创建方法是创建一个嵌套函数，然后内部函数可以访问到外部函数中的变量。  
1、使变量可以驻留在内存，不被回收（核心作用）  
2、使我们能够在函数外部能访问到函数内部的局部变量，即变量私有化  

# 简述localStorage与sessionStorage的区别
1、数据有效期不同
```
localStorage是始终有效，除非手动清除
sessionStorage是仅当前浏览器窗口关闭前有效
```
2、作用域不同
```
localStorage在同源窗口中共享
sessionStorage仅能在当前浏览器窗口有效
```

# 列出css能脱离文档流的属性，并简述它的影响
1、float，脱离后会对原文档流里的元素布局造成影响  
2、position的absolute(绝对定位)和fixed(固定定位)，原文档流元素在它后面的元素会占据它原来的位置

# 谈谈this对象的理解
this是函数的关键字，是个对象，它的指向是动态的，取决于函数的调用方式和上下文环境，默认指向window对象，new形式的话指向本身，作为对象的方法调用则指向对象，call/apply/bind等则指向传入的对象

# 多维数组扁平化(如const arr = [1,2,3,[4,5],6])
1、es6的flat函数
```
let arr1 = arr.flat();//[1,2,3,4,5,6]
```
2、apply
```
let arr1 = [].concat.apply([],arr);//即Array.prototype.concat.apply([],arr) 简写运行时间短
```
3、for循环递归
```
function flatten(arr){
	let arr1 = [];
	for(let i=0; i < arr.length; i++){
		if(Array.isArray(arr[i])){
			arr1 = arr1.concat(flatten(arr[i])) 
		}else{
			arr1.push(arr[i])
		}
	}
	return arr1;
}
flatten(arr);//结果为[1,2,3,4,5,6]
```
# 正则实现千分位添加
```
const num = "12345678";
const reg = /(\d)(?=(?:\d{3})+$)/g //即获取一个字符串，它是数字并且它后面有一个或多个以3个数字组成的组合结尾的
console.log(num.replace(reg,'$1,'))//"12,345,678"
```
# 深拷贝是什么，它的应用场景，写一个函数实现
解释：拷贝原数据的所有的属性,并且地址也与原来的不同,这样的话,你改变当前的属性也不会影响原来的  
应用场景：复制深层次的object数据结构  
实现：  
1、JSON.parse(JSON.stringify())，缺陷：如果原始对象有函数则无法实现  
2、递归赋值
```
   function deepClone(oldData) {
      if (typeof oldData === 'object' && oldData !== null) {
        const res = Array.isArray(oldData) ? [] : {}
        for (const key in oldData) {
          if (Object.hasOwnProperty.call(oldData, key)) {
            const element = oldData[key];
            res[key] = deepClone(element)
          }
        }
        return res
      } else {
        return oldData
      }
    }
```

# 盒模型
页面上显示的每个元素都可以看作一个盒子，即盒模型，由margin、border、padding、content四部分组成，盒模型分为：  
1、标准盒模型：css设置width指的是content的width，获取到的总宽度等于两边margin+两边border+两边padding+content之和  
2、IE盒模型：css设置width是指设置content+padding+border的width，总宽度等于两边border+两边padding+content之和（即设置的本身）  
更改属性：box-sizing:content-box(标准)|border-box(IE)

# 移动端的适配
1、rem
```
// 假设设计稿是750px宽度的，然后设置1rem=100px
(function (doc, win, pwidth, prem) {
    var docEl = doc.documentElement,
        resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize',
        recalc = function () {
            var clientWidth = docEl.clientWidth;
            if (!clientWidth) return;
            docEl.style.fontSize = clientWidth / pwidth * prem + 'px';
        };
    if (!doc.addEventListener) return;
    win.addEventListener(resizeEvt, recalc, false);
    doc.addEventListener('DOMContentLoaded', recalc, false);
})(document, window, 750, 100);
```
2、vm/vw  
3、amfe-flexible和postcss-pxtorem(vue)  
4、media

# 图片垂直居中
1、flex布局  
2、position  
3、加一个内联元素辅助

# 同步和异步事件
同步：按照一定的顺序去执行，执行完一个才能执行下一个，可以保证顺序一致，但是容易导致阻塞   
异步：执行顺序是不确定的，由触发条件决定，什么时间执行也是不确定的，异步处理可以同时执行多个。可以解决阻塞问题，但是会改变顺序性  
js是单线程的，浏览器是多线程的，所以可以同时执行多个异步事件

# 事件循环机制
简单的说，事件循环（eventLoop）是单线程的JavaScript在处理异步事件时进行的一种循环过程，具体来讲，对于异步事件它会先加入到事件队列中挂起，等主线程空闲时会去执行事件队列中的事件。  
主线程任务-微任务(promise.then,async/await)-宏任务(setTimeout)

# webpack
## 原理
webpack是一个现代化的静态模块打包工具，它的工作步骤是先找到入口文件，然后递归查找需处理的模块生成依赖图，然后用loader加载和处理模块，最后进行资源的优化和分割然后输出文件
## loader
webpack默认只加载js和json文件，其他文件就需要loader加载处理了  
常见的loader：  
JS：babel-loader(处理ES6)、ts-loader（处理ts）、vue-loader（处理vue文件）  
CSS：css-loader、scss-loader、postcss-loader、style-loader  
静态资源：file-loader、image-loader
## plugin
作用是在webpack打包过程中的一些关键节点做一些操作，如压缩混淆等  
常见：CleanWebpackPlugin,compressWebpackPlugin,HtmlWebpackPlugin,MinCssExtractPlugin,DefinePlgin,UglifyPlugin,CopyWebpackPlugin等等
## 分包策略
webpack默认是把所有资源都打包到一个文件，这样会导致体积过大，导致首屏加载速度慢，以及缓存效率低  
作用：1、提高首屏加载速度 2、提高缓存效率  
策略：1、多入口项目可以采用entry分包；2、SPA项目可以用import动态引入进行分包，比如在路由文件引入时；3、最后还有一个把运行文件单独分包
## 文件指纹技术
指把文件内容都进行哈希运算并把它反馈到文件名上，确保文件内容不同文件名也不同的技术  
策略：1、全局；2、chunk；3、文件
## SourceMap
指的是编译后的代码与源代码的映射文件
## 提高效率
1、启用缓存  
2、启用多线程  
3、启用新的高效编译器，如esbuild

# 箭头函数和普通函数的区别
1、箭头函数不会创建自己的this，继承而来的this指向永远不变  
2、箭头函数不能作为构造函数使用，也就是不能new  
3、箭头函数没有原型prototype

# 在实际项目中你是如何使用scss的
1、嵌套  
2、定义变量($xxxx)  
3、继承(@extend)  
4、混入(#include)  

# postion的解释
1、position: static;：静态定位，不进行定位，默认状态  
2、relative：相对定位 相对于其原来的位置进行定位  
3、absolute：绝对定位 相对于最近的有定位的元素进行定位，如果没有则是html元素 脱离了文档流  
4、fixed：固定定位 相对于html元素定位 脱离了文档流  
5、sticky：粘性定位 当它在屏幕内出现时不进行定位，当不在屏幕内就以最近的拥有滚动机制的元素进行定位

# XSS 和 CSRF 攻击
## XSS
即跨站脚本攻击，指用户在页面上输入了代码内容，存储到服务器了，然后后面访问了带有脚本代码的页面时会执行该代码进而导致隐私泄露  
解决：  
1、对用户输入内容进行过滤或转码  
2、充分利用 CSP  
3、使用 HttpOnly 属性
## CSRF
CSRF攻击就是当用户在A网站登陆了，然后黑客诱惑用户点击了有害的网站，然后在网站页面上请求了A网站的接口，这个时候浏览器会自动带上A域名下的cookie，从而被黑客利用  
解决：  
1、充分利用好Cookie的SameSite属性
2、验证请求的来源站点
3、利用CSRF Token校验

# var、let、const的区别
1、var存在变量提升机制，即在同一作用域下，无论声明在哪个位置都可以使用，let，const则没有，必须先声明后使用  
2、var可以在同一个作用域内重复声明，let、const不行  
3、在全局作用域下var声明是挂载到window上的，let，const则不是  
4、var和let都可以被整体修改原值，const则不行，而且必须在声明的时候赋值

# apply、call、bind
1、三者都是用来改变函数的this对象的指向的；  
2、三者第一个参数都是this要指向的对象，也就是想指定的上下文；  
3、三者都可以利用后续参数传参（call是所有参数直接放进去用,隔开，apply必须放到数组中（接收参数解构），bind和call一样）  
4、bind不会立即调用会返回一个新的函数，便于稍后调用；apply 、call 则是立即调用。

# 冒泡和捕获
## 冒泡
解释：当一个事件发生在一个元素上，它会首先触发在该元素上的处理程序，然后逐级往上触发其父元素上的处理程序。  
event.target指触发事件的那个元素  
停止：event.stopPropagation()  
## 捕获
解释：当元素被触发事件时候，从该元素的根节点开始逐级向里寻找同类型事件。这个过程，就被称为事件捕获  
事件传播3阶段：1、捕获阶段，2、目标阶段，3、冒泡阶段   

# ES6新特性
1、let,const  
2、箭头函数  
3、模板字符串(``)  
3、对象解构赋值(const { name, age } = {name:1,ager:2};const {a,b,c}=[1,2,3])  
4、展开运算符([...arr])  
5、类和继承(class,extends)  
6、promise和proxy  
7、字符串新方法(includes,startsWith/endsWith,repeat,padStart/padEnd)  
8、数组新方法(Array.from,includes,map,filter,forEach,find,some,every)  
9、object的新方法(Object.assign,Object.is,Object.keys()、Object.values()、Object.entries())  
10、函数传参默认值  

# promise
解释：将异步操作以同步操作的形式表达出来  
3个状态：pending-resolve-rejected  
并发：Promise.all(所有都通过或有一个被拒绝),Promise.allSettled(所有都通过),Promise.any(任意一个通过或所有被拒绝),Promise.race(任意一个通过或拒绝)
